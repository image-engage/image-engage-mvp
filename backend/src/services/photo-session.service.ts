// src/services/photo-session.service.ts
import { supabase } from '../config/database'; // Assuming this imports your Supabase client
import { ApiResponse, PatientConsent, PhotoSession, MediaFile } from '../types';
import { PatientService } from './patient.service'; // ðŸ‘ˆ Import PatientService
import { EnhancedQualityService } from './enhanced-quality.service';
import { v4 as uuidv4 } from 'uuid';
import { Express } from 'express'; // Import Express for Multer file type

interface Patient {
  id: string;
  first_name: string;
  last_name: string;
  last_photo_session: string | null;
}

/**
 * The final, flat structure we want for our component.
 */
interface WaitingPatient {
  id: string;
  first_name: string;
  last_name: string;
  procedure: string;
  before_photos_taken: boolean;
  after_photos_taken: boolean;
}

/**
 * Service class for handling photo session-related operations,
 * including file uploads to Supabase Storage and database record creation.
 */
export class PhotoSessionService {

  // Define the Supabase Storage bucket name for photo sessions
  private static readonly SUPABASE_BUCKET_NAME = 'photo-sessions';

  /**
   * Core function to handle the entire photo upload and session creation workflow.
   *
   * @param practiceId The ID of the dental practice.
   * @param patientId The ID of the patient.
   * @param patientPhotoId The unique ID generated by the frontend for this photo session.
   * @param files An array of file objects to upload.
   * @param categories An array of categories (e.g., 'before', 'after', 'other') corresponding to each file.
   * @returns An ApiResponse indicating the result of the operation.
   */
  static async createPhotoSessionAndUpload(
    practiceId: string,
    patientId: string,
    patientPhotoId: string, // Receiving this from the frontend/controller
    files: Express.Multer.File[],
    categories: string[] // Receiving an array of categories, one per file
  ): Promise<ApiResponse> {
    try {
      // Step 1: Get patient info and validate existence
      const { data: patient, error: patientError } = await supabase
        .from('patients')
        .select('*')
        .eq('id', patientId)
        .eq('practice_id', practiceId)
        .single();

      if (patientError || !patient) {
        return { success: false, message2: 'Patient not found or database error' };
      }

      // FIX: Removed the consent_status check as the 'patients' table no longer has this column.
      // If consent management is needed, add a 'consent_status' column to the 'patients' table
      // or a separate 'patient_consents' table and re-implement the check.

      // Step 2: Upload files to Supabase Storage and analyze quality
      const uploadedFileUrls: string[] = [];
      const mediaRecords: any[] = [];
      const uploadPromises = files.map(async (file, index) => {
        const category = categories[index]; // Get the category for the current file

        // Analyze image quality for photos
        let qualityMetrics = null;
        if (file.mimetype.startsWith('image/')) {
          try {
            qualityMetrics = await EnhancedQualityService.analyzeImage(file.buffer);
          } catch (error) {
            console.error('Quality analysis failed:', error);
          }
        }

        // Construct the folder path based on file type and category
        let fullPath = '';
        if (file.mimetype === 'application/pdf') {
          // PDF consent forms: {{practiceId}}/_ConsentForms/Before/{{sessionId}}/filename.pdf
          fullPath = `${practiceId}/_ConsentForms/Before/${patientPhotoId}/${file.originalname}`;
        } else {
          // Photos and videos: {{practiceId}}/_RawPhotos/Before/{{sessionId}}/filename.jpg
          let folderPathSegment = '';
          switch (category) {
            case 'before':
              folderPathSegment = 'Before';
              break;
            case 'after':
              folderPathSegment = 'After';
              break;
            case 'other':
            default:
              folderPathSegment = 'Other';
              break;
          }
          fullPath = `${practiceId}/_RawPhotos/${folderPathSegment}/${patientPhotoId}/${file.originalname}`;
        }

        const uploadResult = await this.uploadFile(
          PhotoSessionService.SUPABASE_BUCKET_NAME,
          file,
          fullPath
        );

        if (!uploadResult.success) {
          // If any upload fails, throw an error to stop the Promise.all
          throw new Error(uploadResult.message2 || `Failed to upload file: ${file.originalname}`);
        }
        uploadedFileUrls.push(uploadResult.data!.url); // Store the public URL
        
        // Store media record with quality metrics
        const mediaRecord = {
          practice_id: practiceId,
          patient_id: patientId,
          patient_photo_id: patientPhotoId,
          category: category,
          media_type: file.mimetype.startsWith('image/') ? 'photo' : 'video',
          file_type: file.mimetype,
          original_filename: file.originalname,
          storage_path: fullPath,
          storage_url: uploadResult.data!.url,
          file_size: file.size,
          quality_score: qualityMetrics?.qualityScore || 0,
          brightness_level: qualityMetrics?.brightnessLevel || 0,
          contrast_score: qualityMetrics?.contrastScore || 0,
          sharpness_rating: qualityMetrics?.sharpnessRating || 0,
          quality_status: qualityMetrics?.status || 'pending',
          quality_feedback: qualityMetrics?.feedback || null
        };
        mediaRecords.push(mediaRecord);
        
        return uploadResult;
      });

      // Wait for all file uploads to complete. If any promise rejects, Promise.all will reject.
      await Promise.all(uploadPromises);

      // Step 3: Save media files with quality metrics to database
      if (mediaRecords.length > 0) {
        const { error: mediaError } = await supabase
          .from('media_files')
          .insert(mediaRecords);
        
        if (mediaError) {
          console.error('Failed to save media records:', mediaError);
        }
      }

      // Step 4: Create the photo session record and update workflow state
      const baseStorageFolderPath = `${practiceId}/_RawPhotos/${categories[0] || 'Other'}/${patientPhotoId}/`;

      const sessionResult = await this.createPhotoSessionRecord(
        practiceId,
        patientId,
        patientPhotoId,
        files.length,
        uploadedFileUrls,
        categories,
        baseStorageFolderPath
      );

      if (!sessionResult.success) {
        return sessionResult;
      }

      // Step 5: Update workflow session state
      await this.updateWorkflowSession(practiceId, patientId, categories);

      return {
        success: true,
        message2: 'Photos uploaded successfully and session created',
        data: {
          patientPhotoId,
          photosCount: files.length,
          uploadedFileUrls, // Return the URLs to the frontend if needed
          categories // Return categories if needed
        }
      };
    } catch (error: any) {
      console.error('Error creating photo session and uploading photos:', error);
      // Return a consistent error message2
      return { success: false, message2: error.message || 'Internal server error during photo session creation.' };
    }
  }

  /**
   * Handles the upload of general, ad-hoc media not tied to a specific workflow.
   *
   * @param practiceId The ID of the dental practice.
   * @param files An array of file objects to upload.
   * @param patientId The optional ID of the patient to associate the media with.
   * @param descriptions An array of descriptions corresponding to each file.
   * @param mediaTypes An array of media types ('photo' or 'video') for each file.
   * @returns An ApiResponse indicating the result of the operation.
   */
  static async uploadGeneralMedia(
    practiceId: string,
    files: Express.Multer.File[],
    patientId: string | null,
    descriptions: string[],
    mediaTypes: string[]
  ): Promise<ApiResponse> {
    try {
      const patientPhotoId = `adhoc_${uuidv4()}`; // A unique identifier for this batch of uploads
      const uploadedFileUrls: string[] = [];
      const mediaMetadata: Partial<MediaFile>[] = [];

      // Step 1: Upload files to Supabase Storage
      const uploadPromises = files.map(async (file, index) => {
        const description = descriptions[index] || '';
        const mediaType = mediaTypes[index] || 'photo';

        // Construct a dedicated storage path for general media
        const patientFolder = patientId ? patientId : '_Practice';
        const fullPath = `${practiceId}/_GeneralMedia/${patientFolder}/${patientPhotoId}/${file.originalname}`;

        const uploadResult = await this.uploadFile(
          PhotoSessionService.SUPABASE_BUCKET_NAME,
          file,
          fullPath
        );

        if (!uploadResult.success || !uploadResult.data?.url) {
          throw new Error(uploadResult.message2 || `Failed to upload file: ${file.originalname}`);
        }

        uploadedFileUrls.push(uploadResult.data.url);
        mediaMetadata.push({
          original_filename: file.originalname,
          storage_path: fullPath,
          storage_url: uploadResult.data.url,
          media_type: mediaType as 'photo' | 'video',
          category: 'other', // Using 'other' as it's not before/after
          //description: description, // Storing the description
          file_size: file.size,
        });
      });

      await Promise.all(uploadPromises);

      // Step 2: Create a single photo session record for this ad-hoc batch
      const sessionId = uuidv4();
      const currentDate = new Date().toISOString();

      const { data: session, error } = await supabase
        .from('photo_sessions')
        .insert({
          id: sessionId,
          practice_id: practiceId,
          patient_id: patientId, // Can be null
          patient_photo_id: patientPhotoId,
          session_date: currentDate,
          photos_count: files.length,
          file_urls: uploadedFileUrls,
          photo_type: 'general', // The key differentiator for this type of upload
          storage_folder_path: `${practiceId}/_GeneralMedia/${patientId ? patientId : '_Practice'}/${patientPhotoId}/`,
          status: 'uploaded',
          media_metadata: mediaMetadata, // Storing detailed metadata
          created_at: currentDate,
          updated_at: currentDate
        })
        .select()
        .single();

      if (error) {
        console.error('Database error creating general photo session record:', error);
        return { success: false, message2: 'Failed to create general media session record' };
      }

      // Step 3: DO NOT update workflow session state, as this is outside the workflow.

      return {
        success: true,
        message2: 'Media uploaded successfully',
        data: {
          patientPhotoId,
          filesUploaded: files.length,
          sessionRecord: session,
        }
      };
    } catch (error: any) {
      console.error('Error in uploadGeneralMedia:', error);
      return { success: false, message2: error.message || 'Internal server error during general media upload.' };
    }
  }

  /**
   * Helper function to upload a single file to a Supabase Storage bucket.
   */
  private static async uploadFile(
    bucketName: string,
    file: Express.Multer.File,
    filePath: string
  ): Promise<ApiResponse<{ url: string }>> {
    try {
      // Use file.buffer and file.mimetype for memory storage uploads
      const { error } = await supabase.storage
        .from(bucketName)
        .upload(filePath, file.buffer, {
            contentType: file.mimetype,
            upsert: false // Set to true if you want to overwrite existing files with the same path
        });

      if (error) {
        console.error('Supabase upload error:', error);
        return {
          success: false,
          message2: `Failed to upload file "${file.originalname}": ${error.message}`
        };
      }

      // Get the public URL for the uploaded file
      const { data: publicUrlData } = supabase.storage
        .from(bucketName)
        .getPublicUrl(filePath);

      if (!publicUrlData || !publicUrlData.publicUrl) {
          return {
              success: false,
              message2: `Failed to get public URL for file: ${file.originalname}`
          };
      }

      return {
        success: true,
        message2: 'File uploaded successfully',
        data: {
          url: publicUrlData.publicUrl
        }
      };
    } catch (error) {
      console.error('Unexpected error during file upload:', error);
      return {
        success: false,
        message2: 'Internal server error during file upload'
      };
    }
  }

  /**
   * Helper function to create a photo session record and update the patient's last photo session date.
   */
  private static async createPhotoSessionRecord(
    practiceId: string,
    patientId: string,
    patientPhotoId: string,
    photosCount: number,
    uploadedFileUrls: string[], // Now stores an array of URLs
    categories: string[], // Now stores an array of categories
    storageFolderPath: string // The base folder path for the session
  ): Promise<ApiResponse<PhotoSession>> {
    try {
      const sessionId = uuidv4(); // Generate a unique ID for the database record
      const currentDate = new Date().toISOString();

      const { data: session, error } = await supabase
        .from('photo_sessions')
        .insert({
          id: sessionId,
          practice_id: practiceId,
          patient_id: patientId,
          patient_photo_id: patientPhotoId, // The ID used for folder structure
          session_date: currentDate,
          photos_count: photosCount,
          file_urls: uploadedFileUrls, // Store the array of public URLs
          // Store categories as a comma-separated string.
          photo_type: categories.join(','),
          storage_folder_path: storageFolderPath, // Store the base folder path
          status: 'uploaded', // Or 'completed'
          created_at: currentDate,
          updated_at: currentDate
        })
        .select()
        .single();

      if (error) {
        console.error('Database error creating photo session record:', error);
        return { success: false, message2: 'Failed to create photo session record' };
      }

      // FIX: Update the patient's last photo session using the correct service and value
      const updateResult = await PatientService.updateLastPhotoSession(
        practiceId,
        patientId,
        patientPhotoId // ðŸ‘ˆ Use the session ID, not the date
      );
      if (!updateResult.success) {
        console.warn(`Failed to update last_photo_session for patient ${patientId}: ${updateResult.message2}`);
      }

      return { success: true, message2: 'Photo session record created successfully', data: session };
    } catch (error) {
      console.error('Error creating photo session record:', error);
      return { success: false, message2: 'Internal server error during session record creation.' };
    }
  }

  /**
   * Retrieves a single photo session by its patient_photo_id.
   */
  static async getPhotoSessionById(practiceId: string, patientPhotoId: string): Promise<ApiResponse<PhotoSession>> {
    try {      
      // FIX: Fetch ALL sessions matching the patientPhotoId, not just the last one.
      const { data: sessions, error } = await supabase
        .from('photo_sessions')
        .select('*')
        .eq('practice_id', practiceId)
        .eq('patient_photo_id', patientPhotoId)
        .order('session_date', { ascending: true }); // Order by date to combine correctly

      if (error) {
        console.error(`Database error retrieving session ${patientPhotoId}:`, error);
        return { success: false, message2: 'Failed to retrieve photo session.' };
      }

      if (!sessions || sessions.length === 0) {
        return { success: false, message2: `Photo session with ID ${patientPhotoId} not found.` };
      }

      // Aggregate data from all found session records (e.g., 'before' and 'after' uploads)
      const aggregatedSession = sessions.reduce((acc, current) => {
        // Use the latest session as the base
        acc.id = current.id;
        acc.patient_id = current.patient_id;
        acc.session_date = current.session_date; // Keep the latest date
        
        // Combine file URLs and photo types
        acc.file_urls = [...(acc.file_urls || []), ...(current.file_urls || [])];
        const currentPhotoTypes = (current.photo_type || '').split(',');
        const accPhotoTypes = (acc.photo_type || '').split(',').filter(Boolean);
        acc.photo_type = [...accPhotoTypes, ...currentPhotoTypes].join(',');

        acc.photos_count = (acc.photos_count || 0) + (current.photos_count || 0);
        return acc;
      }, { ...sessions[0], file_urls: [], photo_type: '', photos_count: 0 });


      return { success: true, message2: 'Photo session retrieved successfully', data: aggregatedSession };

    } catch (error) {
      console.error('Error in getPhotoSessionById:', error);
      return { 
        success: false, 
        message2: 'Internal server error while retrieving photo session.' 
      };
    }
  }

  /**
   * Retrieves all photo sessions for a given practice.
   */
  static async getPhotoSessionsByPractice(practiceId: string): Promise<ApiResponse<PhotoSession[]>> {
    try {
      const { data: sessions, error } = await supabase
        .from('photo_sessions')
        .select(`
          *,
          patients (
            first_name,
            last_name,
            procedure_type
          )
        `)
        .eq('practice_id', practiceId)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Database error retrieving photo sessions:', error);
        return { success: false, message2: 'Failed to retrieve photo sessions' };
      }

      return { success: true, message2: 'Photo sessions retrieved successfully', data: sessions || [] };
    } catch (error) {
      console.error('Error retrieving photo sessions:', error);
      return { success: false, message2: 'Internal server error retrieving photo sessions.' };
    }
  }

/**
 * Fetches patients who are ready for a photo session using workflow sessions table.
 * @param {string} practiceId - The ID of the practice.
 * @returns {Promise<ApiResponse<WaitingPatient[]>>}
 */
  static async getWaitingPatients(practiceId: string): Promise<ApiResponse<WaitingPatient[]>> {
    try {
      const { data, error } = await supabase
        .from('patients')
        .select(`
          id,
          first_name,
          last_name,
          patient_workflow_sessions (
            current_step,
            before_photos_completed,
            after_photos_completed
          ),
          consent_forms (
            procedure_type
          )
        `)
        .eq('practice_id', practiceId);

      if (error) {
        console.error('Supabase error fetching waiting patients:', error);
        return {
          success: false,
          message2: 'Failed to fetch waiting patients.'
        };
      }

      const waitingPatients: WaitingPatient[] = (data || [])
        .filter((patient: any) => {
          // Only include patients with consent forms
          if (!patient.consent_forms?.length) return false;
          
          // Only include patients with active workflow sessions (not completed)
          const workflowSession = patient.patient_workflow_sessions?.[0];
          return workflowSession && workflowSession.current_step !== 'completed';
        })
        .map((patient: any) => {
          const workflowSession = patient.patient_workflow_sessions?.[0];
          const consent = patient.consent_forms?.[0];
          
          return {
            id: patient.id,
            first_name: patient.first_name,
            last_name: patient.last_name,
            procedure: consent?.procedure_type || 'Unknown Procedure',
            before_photos_taken: workflowSession?.before_photos_completed || false,
            after_photos_taken: workflowSession?.after_photos_completed || false,
          };
        });

      return {
        success: true,
        message2: 'Waiting patients fetched successfully.',
        data: waitingPatients
      };
    } catch (err) {
      console.error('Error fetching waiting patients:', err);
      return {
        success: false,
        message2: 'Failed to fetch waiting patients.'
      };
    }
  }


  /**
   * Creates or updates a workflow session for a patient.
   */
  static async createOrUpdateWorkflowSession(practiceId: string, patientId: string): Promise<ApiResponse> {
    try {
      const { data: existing, error: fetchError } = await supabase
        .from('patient_workflow_sessions')
        .select('*')
        .eq('practice_id', practiceId)
        .eq('patient_id', patientId)
        .single();

      if (fetchError && fetchError.code !== 'PGRST116') {
        return { success: false, message2: 'Failed to check existing workflow session' };
      }

      if (existing) {
        return { success: true, message2: 'Workflow session already exists', data: existing };
      }

      const { data: newSession, error } = await supabase
        .from('patient_workflow_sessions')
        .insert({
          practice_id: practiceId,
          patient_id: patientId,
          current_step: 'before_photos'
        })
        .select()
        .single();

      if (error) {
        return { success: false, message2: 'Failed to create workflow session' };
      }

      return { success: true, message2: 'Workflow session created', data: newSession };
    } catch (err) {
      return { success: false, message2: 'Error managing workflow session' };
    }
  }

  /**
   * Updates workflow session state after photo upload.
   */
  static async updateWorkflowSession(practiceId: string, patientId: string, categories: string[]): Promise<void> {
    try {
      const hasBeforePhotos = categories.includes('before');
      const hasAfterPhotos = categories.includes('after');
      
      const { data: session } = await supabase
        .from('patient_workflow_sessions')
        .select('*')
        .eq('practice_id', practiceId)
        .eq('patient_id', patientId)
        .single();

      if (!session) return;

      const updates: any = { updated_at: new Date().toISOString() };
      
      if (hasBeforePhotos) {
        updates.before_photos_completed = true;
        updates.before_completed_at = new Date().toISOString();
        if (!session.after_photos_completed) {
          updates.current_step = 'after_photos';
        }
      }
      
      if (hasAfterPhotos) {
        updates.after_photos_completed = true;
        updates.after_completed_at = new Date().toISOString();
      }
      
      if ((session.before_photos_completed || hasBeforePhotos) && hasAfterPhotos) {
        updates.current_step = 'completed';
        updates.workflow_completed_at = new Date().toISOString();
      }

      await supabase
        .from('patient_workflow_sessions')
        .update(updates)
        .eq('practice_id', practiceId)
        .eq('patient_id', patientId);
    } catch (err) {
      console.error('Error updating workflow session:', err);
    }
  }
}
