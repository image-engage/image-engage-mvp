// src/services/photo-session.service.ts
import { supabase } from '../config/database'; // Assuming this imports your Supabase client
import { ApiResponse, PatientConsent, PhotoSession } from '../types';
import { PatientService } from './patient.service'; // ðŸ‘ˆ Import PatientService
import { v4 as uuidv4 } from 'uuid';
import { Express } from 'express'; // Import Express for Multer file type

interface Patient {
  id: string;
  first_name: string;
  last_name: string;
  last_photo_session: string | null;
}

/**
 * The final, flat structure we want for our component.
 */
interface WaitingPatient {
  id: string;
  first_name: string;
  last_name: string;
  procedure: string;
  before_photos_taken: boolean;
  after_photos_taken: boolean;
}

/**
 * Service class for handling photo session-related operations,
 * including file uploads to Supabase Storage and database record creation.
 */
export class PhotoSessionService {

  // Define the Supabase Storage bucket name for photo sessions
  private static readonly SUPABASE_BUCKET_NAME = 'photo-sessions';

  /**
   * Core function to handle the entire photo upload and session creation workflow.
   *
   * @param practiceId The ID of the dental practice.
   * @param patientId The ID of the patient.
   * @param patientPhotoId The unique ID generated by the frontend for this photo session.
   * @param files An array of file objects to upload.
   * @param categories An array of categories (e.g., 'before', 'after', 'other') corresponding to each file.
   * @returns An ApiResponse indicating the result of the operation.
   */
  static async createPhotoSessionAndUpload(
    practiceId: string,
    patientId: string,
    patientPhotoId: string, // Receiving this from the frontend/controller
    files: Express.Multer.File[],
    categories: string[] // Receiving an array of categories, one per file
  ): Promise<ApiResponse> {
    try {
      // Step 1: Get patient info and validate existence
      const { data: patient, error: patientError } = await supabase
        .from('patients')
        .select('*')
        .eq('id', patientId)
        .eq('practice_id', practiceId)
        .single();

      if (patientError || !patient) {
        return { success: false, message2: 'Patient not found or database error' };
      }

      // FIX: Removed the consent_status check as the 'patients' table no longer has this column.
      // If consent management is needed, add a 'consent_status' column to the 'patients' table
      // or a separate 'patient_consents' table and re-implement the check.

      // Step 2: Upload files to Supabase Storage
      const uploadedFileUrls: string[] = [];
      const uploadPromises = files.map(async (file, index) => {
        const category = categories[index]; // Get the category for the current file

        // Construct the folder path based on file type and category
        let fullPath = '';
        if (file.mimetype === 'application/pdf') {
          // PDF consent forms: {{practiceId}}/_ConsentForms/Before/{{sessionId}}/filename.pdf
          fullPath = `${practiceId}/_ConsentForms/Before/${patientPhotoId}/${file.originalname}`;
        } else {
          // Photos and videos: {{practiceId}}/_RawPhotos/Before/{{sessionId}}/filename.jpg
          let folderPathSegment = '';
          switch (category) {
            case 'before':
              folderPathSegment = 'Before';
              break;
            case 'after':
              folderPathSegment = 'After';
              break;
            case 'other':
            default:
              folderPathSegment = 'Other';
              break;
          }
          fullPath = `${practiceId}/_RawPhotos/${folderPathSegment}/${patientPhotoId}/${file.originalname}`;
        }

        const uploadResult = await this.uploadFile(
          PhotoSessionService.SUPABASE_BUCKET_NAME,
          file,
          fullPath
        );

        if (!uploadResult.success) {
          // If any upload fails, throw an error to stop the Promise.all
          throw new Error(uploadResult.message2 || `Failed to upload file: ${file.originalname}`);
        }
        uploadedFileUrls.push(uploadResult.data!.url); // Store the public URL
        return uploadResult;
      });

      // Wait for all file uploads to complete. If any promise rejects, Promise.all will reject.
      await Promise.all(uploadPromises);

      // Step 3: Create the photo session record and update workflow state
      const baseStorageFolderPath = `${practiceId}/_RawPhotos/${categories[0] || 'Other'}/${patientPhotoId}/`;

      const sessionResult = await this.createPhotoSessionRecord(
        practiceId,
        patientId,
        patientPhotoId,
        files.length,
        uploadedFileUrls,
        categories,
        baseStorageFolderPath
      );

      if (!sessionResult.success) {
        return sessionResult;
      }

      // Step 4: Update workflow session state
      await this.updateWorkflowSession(practiceId, patientId, categories);

      return {
        success: true,
        message2: 'Photos uploaded successfully and session created',
        data: {
          patientPhotoId,
          photosCount: files.length,
          uploadedFileUrls, // Return the URLs to the frontend if needed
          categories // Return categories if needed
        }
      };
    } catch (error: any) {
      console.error('Error creating photo session and uploading photos:', error);
      // Return a consistent error message2
      return { success: false, message2: error.message || 'Internal server error during photo session creation.' };
    }
  }

  /**
   * Helper function to upload a single file to a Supabase Storage bucket.
   */
  private static async uploadFile(
    bucketName: string,
    file: Express.Multer.File,
    filePath: string
  ): Promise<ApiResponse<{ url: string }>> {
    try {
      // Use file.buffer and file.mimetype for memory storage uploads
      const { error } = await supabase.storage
        .from(bucketName)
        .upload(filePath, file.buffer, {
            contentType: file.mimetype,
            upsert: false // Set to true if you want to overwrite existing files with the same path
        });

      if (error) {
        console.error('Supabase upload error:', error);
        return {
          success: false,
          message2: `Failed to upload file "${file.originalname}": ${error.message}`
        };
      }

      // Get the public URL for the uploaded file
      const { data: publicUrlData } = supabase.storage
        .from(bucketName)
        .getPublicUrl(filePath);

      if (!publicUrlData || !publicUrlData.publicUrl) {
          return {
              success: false,
              message2: `Failed to get public URL for file: ${file.originalname}`
          };
      }

      return {
        success: true,
        message2: 'File uploaded successfully',
        data: {
          url: publicUrlData.publicUrl
        }
      };
    } catch (error) {
      console.error('Unexpected error during file upload:', error);
      return {
        success: false,
        message2: 'Internal server error during file upload'
      };
    }
  }

  /**
   * Helper function to create a photo session record and update the patient's last photo session date.
   */
  private static async createPhotoSessionRecord(
    practiceId: string,
    patientId: string,
    patientPhotoId: string,
    photosCount: number,
    uploadedFileUrls: string[], // Now stores an array of URLs
    categories: string[], // Now stores an array of categories
    storageFolderPath: string // The base folder path for the session
  ): Promise<ApiResponse<PhotoSession>> {
    try {
      const sessionId = uuidv4(); // Generate a unique ID for the database record
      const currentDate = new Date().toISOString();

      const { data: session, error } = await supabase
        .from('photo_sessions')
        .insert({
          id: sessionId,
          practice_id: practiceId,
          patient_id: patientId,
          patient_photo_id: patientPhotoId, // The ID used for folder structure
          session_date: currentDate,
          photos_count: photosCount,
          file_urls: uploadedFileUrls, // Store the array of public URLs
          // Store categories as a comma-separated string.
          photo_type: categories.join(','),
          storage_folder_path: storageFolderPath, // Store the base folder path
          status: 'uploaded', // Or 'completed'
          created_at: currentDate,
          updated_at: currentDate
        })
        .select()
        .single();

      if (error) {
        console.error('Database error creating photo session record:', error);
        return { success: false, message2: 'Failed to create photo session record' };
      }

      // FIX: Update the patient's last photo session using the correct service and value
      const updateResult = await PatientService.updateLastPhotoSession(
        practiceId,
        patientId,
        patientPhotoId // ðŸ‘ˆ Use the session ID, not the date
      );
      if (!updateResult.success) {
        console.warn(`Failed to update last_photo_session for patient ${patientId}: ${updateResult.message2}`);
      }

      return { success: true, message2: 'Photo session record created successfully', data: session };
    } catch (error) {
      console.error('Error creating photo session record:', error);
      return { success: false, message2: 'Internal server error during session record creation.' };
    }
  }

  /**
   * Retrieves a single photo session by its patient_photo_id.
   */
  static async getPhotoSessionById(practiceId: string, patientPhotoId: string): Promise<ApiResponse<PhotoSession>> {
    try {
      const { data: session, error } = await supabase
        .from('photo_sessions')
        .select('*') // Select all columns from the photo_sessions table
        .eq('practice_id', practiceId)
        // FIX: The frontend is sending the patient_id as the session identifier.
        // We should query by patient_id and get the most recent session.
        .eq('patient_photo_id', patientPhotoId) 
        .order('session_date', { ascending: false }) // Get the latest session first
        .limit(1) // We only want one session
        .single(); // Expect a single result

      if (error) {
        console.error(`Database error retrieving session ${patientPhotoId}:`, error);
        if (error.code === 'PGRST116') { // "PGRST116" is the code for "0 rows returned" from a .single() query
          return { success: false, message2: `Photo session with ID ${patientPhotoId} not found.` };
        }
        return { success: false, message2: 'Failed to retrieve photo session.' };
      }

      return { success: true, message2: 'Photo session retrieved successfully', data: session };

    } catch (error) {
      console.error('Error in getPhotoSessionById:', error);
      return { 
        success: false, 
        message2: 'Internal server error while retrieving photo session.' 
      };
    }
  }

  /**
   * Retrieves all photo sessions for a given practice.
   */
  static async getPhotoSessionsByPractice(practiceId: string): Promise<ApiResponse<PhotoSession[]>> {
    try {
      const { data: sessions, error } = await supabase
        .from('photo_sessions')
        .select(`
          *,
          patients (
            first_name,
            last_name,
            procedure_type
          )
        `)
        .eq('practice_id', practiceId)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Database error retrieving photo sessions:', error);
        return { success: false, message2: 'Failed to retrieve photo sessions' };
      }

      return { success: true, message2: 'Photo sessions retrieved successfully', data: sessions || [] };
    } catch (error) {
      console.error('Error retrieving photo sessions:', error);
      return { success: false, message2: 'Internal server error retrieving photo sessions.' };
    }
  }

/**
 * Fetches patients who are ready for a photo session using workflow sessions table.
 * @param {string} practiceId - The ID of the practice.
 * @returns {Promise<ApiResponse<WaitingPatient[]>>}
 */
  static async getWaitingPatients(practiceId: string): Promise<ApiResponse<WaitingPatient[]>> {
    try {
      const { data, error } = await supabase
        .from('patients')
        .select(`
          id,
          first_name,
          last_name,
          patient_workflow_sessions (
            current_step,
            before_photos_completed,
            after_photos_completed
          ),
          consent_forms (
            procedure_type
          )
        `)
        .eq('practice_id', practiceId);

      if (error) {
        console.error('Supabase error fetching waiting patients:', error);
        return {
          success: false,
          message2: 'Failed to fetch waiting patients.'
        };
      }

      const waitingPatients: WaitingPatient[] = (data || [])
        .filter((patient: any) => {
          // Only include patients with consent forms
          if (!patient.consent_forms?.length) return false;
          
          // Only include patients with active workflow sessions (not completed)
          const workflowSession = patient.patient_workflow_sessions?.[0];
          return workflowSession && workflowSession.current_step !== 'completed';
        })
        .map((patient: any) => {
          const workflowSession = patient.patient_workflow_sessions?.[0];
          const consent = patient.consent_forms?.[0];
          
          return {
            id: patient.id,
            first_name: patient.first_name,
            last_name: patient.last_name,
            procedure: consent?.procedure_type || 'Unknown Procedure',
            before_photos_taken: workflowSession?.before_photos_completed || false,
            after_photos_taken: workflowSession?.after_photos_completed || false,
          };
        });

      return {
        success: true,
        message2: 'Waiting patients fetched successfully.',
        data: waitingPatients
      };
    } catch (err) {
      console.error('Error fetching waiting patients:', err);
      return {
        success: false,
        message2: 'Failed to fetch waiting patients.'
      };
    }
  }


  /**
   * Creates or updates a workflow session for a patient.
   */
  static async createOrUpdateWorkflowSession(practiceId: string, patientId: string): Promise<ApiResponse> {
    try {
      const { data: existing, error: fetchError } = await supabase
        .from('patient_workflow_sessions')
        .select('*')
        .eq('practice_id', practiceId)
        .eq('patient_id', patientId)
        .single();

      if (fetchError && fetchError.code !== 'PGRST116') {
        return { success: false, message2: 'Failed to check existing workflow session' };
      }

      if (existing) {
        return { success: true, message2: 'Workflow session already exists', data: existing };
      }

      const { data: newSession, error } = await supabase
        .from('patient_workflow_sessions')
        .insert({
          practice_id: practiceId,
          patient_id: patientId,
          current_step: 'before_photos'
        })
        .select()
        .single();

      if (error) {
        return { success: false, message2: 'Failed to create workflow session' };
      }

      return { success: true, message2: 'Workflow session created', data: newSession };
    } catch (err) {
      return { success: false, message2: 'Error managing workflow session' };
    }
  }

  /**
   * Updates workflow session state after photo upload.
   */
  static async updateWorkflowSession(practiceId: string, patientId: string, categories: string[]): Promise<void> {
    try {
      const hasBeforePhotos = categories.includes('before');
      const hasAfterPhotos = categories.includes('after');
      
      const { data: session } = await supabase
        .from('patient_workflow_sessions')
        .select('*')
        .eq('practice_id', practiceId)
        .eq('patient_id', patientId)
        .single();

      if (!session) return;

      const updates: any = { updated_at: new Date().toISOString() };
      
      if (hasBeforePhotos) {
        updates.before_photos_completed = true;
        updates.before_completed_at = new Date().toISOString();
        if (!session.after_photos_completed) {
          updates.current_step = 'after_photos';
        }
      }
      
      if (hasAfterPhotos) {
        updates.after_photos_completed = true;
        updates.after_completed_at = new Date().toISOString();
      }
      
      if ((session.before_photos_completed || hasBeforePhotos) && hasAfterPhotos) {
        updates.current_step = 'completed';
        updates.workflow_completed_at = new Date().toISOString();
      }

      await supabase
        .from('patient_workflow_sessions')
        .update(updates)
        .eq('practice_id', practiceId)
        .eq('patient_id', patientId);
    } catch (err) {
      console.error('Error updating workflow session:', err);
    }
  }
}
